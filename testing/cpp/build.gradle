import edu.wpi.first.toolchain.NativePlatforms

plugins {
    id "cpp"
    id "edu.wpi.first.NativeUtils" version "2024.8.0"
    id 'edu.wpi.first.wpilib.repositories.WPILibRepositoriesPlugin' version '2020.2'
}

nativeUtils.addWpiNativeUtils()
nativeUtils.withCrossRoboRIO()
// nativeUtils.withCrossLinuxArm32()
// nativeUtils.withCrossLinuxArm64()

if (project.hasProperty('releaseMode')) {
  wpilibRepositories.addAllReleaseRepositories(project)
} else {
  wpilibRepositories.addAllDevelopmentRepositories(project)
}

model {
    components {
        all {
            nativeUtils.useAllPlatforms(it)
        }
    }
    binaries {
        withType(NativeBinarySpec).all {
            nativeUtils.usePlatformArguments(it)
        }
    }
}

nativeUtils {
    exportsConfigs {
        // Main library is just default empty. This will export everything
        TestLib {
        }
    }
}


nativeUtils.withRust();

nativeUtilsRust {
    libraries {
        grapple(getLibraryTypeClass('RustStaticLibrary')) {
            archiveName = "grapplefrcdriver"
            addAllVariants(nativeUtils.wpi.platforms)
        }
    }
}

nativeUtils {
    wpi {
        configureDependencies {
            wpiVersion = "2024.+"
            opencvYear = "frc2024"
            googleTestYear = "frc2024"
            niLibVersion = "2024.2.1"
            opencvVersion = "4.8.0-2"
            googleTestVersion = "1.14.0-1"
        }
    }
}

model {
    components {
        TestLib(NativeLibrarySpec) {
            sources {
                cpp {
                    source {
                        srcDirs 'src/main/native/lib'
                        include '**/*.cpp'
                    }
                    exportedHeaders {
                        srcDirs 'src/main/native/include'
                    }
                    lib library: 'grapple', linkage: 'static'
                }
            }
            nativeUtils.useRequiredLibrary(it, 'wpilib_shared')
        }
    }
}

def rust_triple(targetPlatform) {
  def platformName = targetPlatform.name
  if (platformName == "linuxathena") {
    return "armv7-unknown-linux-gnueabi"
  } else if (platformName == "linuxarm32") {
    return "arm-unknown-linux-gnueabihf"
  } else if (platformName == "linuxarm64") {
    return "aarch64-unknown-linux-gnu"
  } else if (platformName == "linuxx86-64") {
    return "x86_64-unknown-linux-gnu"
  } else if (platformName == "osxuniversal") {
    return "x86_64-apple-darwin"
  } else if (platformName == "windowsx86-64") {
    return "x86_64-pc-windows-msvc"
  } else if (platformName == "windowsarm64") {
    return "aarch64-pc-windows-msvc"
  } else {
      println "Unknown target platform $platformName"
      return null
  }
}


import java.nio.file.Files;
import java.nio.file.StandardCopyOption;

task updateRustLibs() {
  doLast {
    nativeUtils.nativeDependencyContainer.getByName("driver_shared", libset -> {
      def debugBuildType = nativeUtils.buildTypes.named('debug').get()
      def releaseBuildType = nativeUtils.buildTypes.named('release').get()
      for (targetPlatform in nativeUtils.platforms) {
        def resolved = libset.resolveNativeDependency(targetPlatform, releaseBuildType, java.util.Optional.empty()).get()
        def resolvedDebug = libset.resolveNativeDependency(targetPlatform, debugBuildType, java.util.Optional.empty()).get()

        def headers = []
        def libs = []

        resolved.getLinkFiles().forEach({ f -> libs += f })
        resolvedDebug.getLinkFiles().forEach({ f -> libs += f })
        resolved.getIncludeRoots().forEach({ f -> headers += f })

        def triple = rust_triple(targetPlatform)
        def outdir = project.file("$buildDir/buildlibs/${triple}")
        new File(outdir, "libs").mkdirs()
        new File(outdir, "headers").mkdirs()

        libs.forEach({ lf ->
          copy {
            from lf
            into "${outdir}/libs"
          }
        })

        headers.forEach({ hd ->
          copy {
            from hd
            into "${outdir}/headers"
          }
        })

        if (targetPlatform.name == "osxuniversal") {
          // 2nd copy needed for arm
          outdir = project.file("$buildDir/buildlibs/aarch64-apple-darwin")
          new File(outdir, "libs").mkdirs()
          new File(outdir, "headers").mkdirs()

          libs.forEach({ lf ->
            copy {
              from lf
              into "${outdir}/libs"
            }
          })

          headers.forEach({ hd ->
            copy {
              from hd
              into "${outdir}/headers"
            }
          })
        }
      }
    })
  }
}

wrapper {
    gradleVersion = '8.5'
    distributionType = Wrapper.DistributionType.BIN
}
